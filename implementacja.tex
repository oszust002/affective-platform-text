\chapter{Implementacja}
\label{cha:implementacja}
W ramach niniejszej pracy magisterskiej stworzono grę elektroniczną, w~której miał zostać wykorzystany przygotowywany prototyp interfejsu do  odczytu zmianów stanów emocjonalnych i~zachowań gracza. Na podstawie analizy silników do tworzenia gier przeprowadzonej w~rozdziale~\ref{cha:specyfikacja} zdecydowano się na wykorzystanie silnika Unity. Głównym powodem takiej decyzji była przede wszystkim ilość materiałów o~tematyce tworzenia gier przy pomocy właśnie silnika Unity, a~także dostępność rozwiązań, które pozwalały na prostą komunikację z~urządzeniami opisanymi w~rozdziale~\ref{cha:architektura}. 

\section{Podstawowe założenia}
Zanim rozpoczęto implementację gry, zostały określone założenia i~wymagania implementacyjne i~projektowe, według których następnie została zbudowana gra:
\begin{enumerate}
	\item Gra powinna zawierać mechaniki afektywne, które modyfikują rozgrywkę w~zależności od zachowania lub stanu emocjonalnego gracza.
	\item Jednym z~elementów implementacyjnych powinien być moduł umożliwiający komunikację z~urządzeniami opisanymi w~rozdziale~\ref{cha:architektura}. Moduł powinien także komunikować się z~serwerem zawierającym moduł do predykcji emocji oraz w~sposób prosty udostępniać zmiany stanu emocjonalnego użytkownika i~jego zachowań. 
	\item Gra powinna mieć możliwość wyboru jednego z~dwóch trybów gry: podstawowego, zawierający standardowe mechaniki gry, oraz wersję afektywną.
	\item Rozgrywka powinna być powtarzalna, tak aby w~trakcie przeprowadzania badań, każdy z~uczestników mógł doświadczyć tych samych elementów gry.
\end{enumerate}

\section{Implementacja gry}
%Opis gry, które elementy za co odpowiadają
Ponieważ przygotowywana gra miała być wykorzystana do przeprowadzenia eksperymentów w~celu ewaluacji opracowanego rozwiązania, zdecydowano, że będzie to gra jednoosobowa. W~trakcie rozgrywki gracz wciela się w~rolę kapitana statku kosmicznego, który musi walczyć z~przeciwnikami, aby przeżyć. Jego zadaniem jest sterowanie statkiem i~pokonanie jak największej liczby przeciwników przy pomocy dostępnego wyposażenia. Rozgrywka podzielona jest na poziomy, w~których trakcie gracz musi zdobyć określoną liczbę punktów. Na każdym z~poziomów dookoła statku generowanych jest kilka rodzajów wrogich statków, których schemat i~szybkość generowania są zróżnicowane w~zależności od poziomu. Z~każdym kolejnym poziomem pojawiają się nowe rodzaje jednostek, które mogą nie tylko wlatywać w~gracza lub do niego strzelać pojedynczymi pociskami, ale również wybuchać w~jego pobliżu, posiadać większą wytrzymałość lub strzelać innymi rodzajami pocisków. Każdy z~przeciwników ma także przypisaną ilość punktów, która jest dodawana do puli po zniszczeniu go. Aby przejść do kolejnego poziomu, gracz musi zebrać odpowiednią liczbę punktów.

Gracz posiada ograniczoną liczbę punktów życia, która zwiększa się po przejściu każdego z~poziomów. Aby urozmaicić rozgrywkę, dookoła gracza mogą pojawić się także wzmocnienia w~postaci innych broni oraz elementów leczących. Innym elementem mającym mocno wpłynąć na rozgrywkę jest moc specjalna, która umożliwia graczowi wypuszczenie fali w~kształcie okręgu, która natychmiastowo niszczy wrogie statki. Ponieważ umiejętność ta bardzo ułatwia rozgrywkę, gracz jest w~stanie użyć jej jedynie co określony czas. 

Aby wyrównać poziom gry i~nie znudzić gracz powtarzalną rozgrywką, każdy z~poziomów posiada także dodatkowy tryb, który jest trudniejszy niż podstawowa rozgrywka. Tryb ten jest uruchamiany na pewien określony czas po spełnieniu specjalnych warunków, które w~zależności od wersji gry są inne. W~trakcie trwania trybu trudnego schemat generowania przeciwników jest zmieniany na ich trudniejsze wersje, posiadające większą ilość życia i~inne umiejętności. Zmienia się także szybkość generowania przeciwników, która zostaje podwojona.

Cała gra została stworzona w~stylu dwuwymiarowym. Na rysunku~\ref{fig:ui} przedstawiony został fragment przykładowej rozgrywki. Oznaczone elementy interfejsu użytkownika to kolejno:
\begin{enumerate}
	\item \textbf{Pasek wskazujący poziom życia bohatera}. Warto zwrócić uwagę na brak oznaczenia dokładnej ilości punktów życia. Ukrycie tej informacji zmusza użytkownika do kontrolowania poziomu życia w~trakcie gry, a~także do unikania wszystkich przeciwników, niezależnie od tego, jakie obrażenia zadają.
	\item \textbf{Ikony aktualnie wybranej broni i~dostępności mocy specjalnej}. Służą one przede wszystkim jako elementy informacyjne. Wskazanie aktualnie wybranej broni pozwala graczowi między innymi na zorientowanie się, czy wzmocnienie w~postaci innego typu pocisków jest lepsze od aktualnie posiadanego. Ikona mocy specjalnej natomiast jest nie tylko wskazaniem jej dostępności. W~trakcie czasu odnowienia mocy specjalnej ikona ta spełnia funkcję orientacyjnego licznika, który wskazuje użytkownikowi, kiedy ponownie będzie mógł z~niej skorzystać.
	\item \textbf{Ilość punktów zdobytych przez gracza oraz pasek postępu dla danego poziomu}. Podobnie jak w~przypadku ilości punktów życia, pasek postępu wskazuje jedynie orientacyjny postęp gracza na danym poziomie, dzięki czemu użytkownik nie jest do końca pewien, kiedy ukończy poziom. Z~drugiej strony wyświetlana jest suma punktów zdobytych w~trakcie całej rozgrywki, co stanowi pewnego rodzaju motywację dla gracza, aby zdobyć jak najwyższy wynik.
\end{enumerate}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{images/ui.png}
	\caption{Ekran gry z~oznaczonymi elementami interfejsu użytkownika}
	\label{fig:ui}
\end{figure}

Tak jak zostało wspomniane na początku rozdziału, do implementacji gry wykorzystano silnik Unity. W~momencie tworzenia projektu gry zdecydowano się na użycie wersji 2018.3.0f2, która jest przeznaczona do tworzenia gier na systemy operacyjne oparte o~architekturę 64-bitową. Ponieważ projektowanie gier przy pomocy tego silnika jest oparte na tworzeniu obiektów, które są wprowadzane w~interakcje pomiędzy sobą, a~logika za to odpowiadająca zawarta jest w~skryptach dołączanych do obiektów, zdecydowano się na stworzenie hierarchii, w~której pierwszym poziomem są poszczególne elementy rozgrywki w~postaci obiektów tworzonych na scenie gry, drugim natomiast są skrypty odpowiadające za logikę danego obiektu lub innych elementów gry takich jak interfejs użytkownika czy postępy gracza. Do obiektów stanowiących główne elementy świata gry należą:
\begin{enumerate}
	\item \textbf{Player} reprezentujący statek, którym kieruje gracz. Poza elementami graficznymi zawiera on następujące skrypty związane ze sterowanym statkiem:
	\begin{itemize}
		\item \textbf{PlayerController}, opisujący sposób poruszania się kontrolowanego statku. Przy jego pomocy ustawiana są także szybkość poruszania się oraz czas potrzebny na wyhamowanie statku.
		\item \textbf{PlayerShooter}, odpowiadający za logikę strzelania przy pomocy wybranej broni, a~także za użycie mocy specjalnej. Jej głównym zadaniem jest zarządzanie tworzeniem pocisków i~aktywacji animacji oraz dźwięków związanych ze strzałem lub aktywacją mocy specjalnej. Skrypt odpowiada także za integrację z~elementami interfejsu użytkownika odpowiedzialnymi za wyświetlanie aktualnie używanej broni i~dostępności mocy specjalnej. Skrypt umożliwia także zmianę aktualnie używanej broni oraz zarządzanie parametrem czasu odnowienia mocy specjalnej. 
		\item \textbf{Player}, odpowiadający za kontrolowanie życia postaci. Mowa tutaj nie tylko o~zmniejszaniu życia po przyjęciu obrażeń lub zwiększaniu podczas leczenia bohatera, ale również ustawianiu nowej wartości maksymalnej ilości punktów życia po zakończeniu poziomu. Skrypt ten zarządza elementem interfejsu użytkownika odpowiedzialnym za wyświetlanie aktualnej ilości punktów życia. Kontroluje także wywołanie animacji i~dźwięków uruchamianych po śmierci bohatera, a~także oddelegowanie akcji odpowiedzialnych za zatrzymanie gry do obiektów sterujących rozgrywką.
	\end{itemize}

	\item \textbf{Obiekty reprezentujące przeciwników}. Każdy z~nich różnił się przypisanymi elementami graficznymi oraz skryptami, które mogą różnić się w~zależności od typu przeciwnika. Do skryptów sterujących logiką przeciwników należą:
	\begin{itemize}
		\item \textbf{Enemy}, odpowiadający przede wszystkim za zarządzanie poziomem życia przeciwnika, zmniejszaniu go po zadaniu obrażeń przez gracza, zmianie elementów graficznych w~zależności od ilości punktów życia przeciwnika, oraz za wywołanie animacji i~dźwięków mających nastąpić po śmierci przeciwnika. Skrypt posiada także parametr związany z~ilością obrażeń zadawanych podczas zderzenia z~graczem i~zarządza samą akcją kolizji, zabierając graczowi ustaloną ilość punktów życia.
		\item \textbf{EnemyMovement}, odpowiadający za sposób poruszania się przeciwnika. W~zależności od typu wroga, skrypt zarządza czy ma się on zbliżać do gracza, okrążać go, czy może stać w~miejscu. Zawiera on parametry dotyczące szybkości przeciwnika, maksymalnej odległości od gracza, oraz dystansu od niego, na jakim część przeciwników ma się zatrzymać.
		\item \textbf{EnemyShooter}, odpowiadający za kontrolę strzałów przeciwnika, ich szybkość, stworzenie pocisków oraz wywołanie efektów dźwiękowych strzału. Skrypt ten jest przypisywany wyłącznie do przeciwników typu strzelającego.
		\item \textbf{EnemyBomber}, zarządzający logiką wybuchu przeciwnika. Kontroluje przede wszystkim zadanie graczowi obrażeń i~odepchnięcie innych przeciwników, jeśli znajdują się w~zadanej przez parametr odległości. Odpowiada także za uruchomienie animacji oraz dźwięku związanych z~odliczaniem do wybuchu.
	\end{itemize}
	
	\item \textbf{Obiekty reprezentujące wzmocnienia, które gracz może zdobyć w~trakcie rozgrywki}. Poza elementami graficznymi, w~zależności od rodzaju wzmocnienia, każdy z~nich ma przypisany do siebie następujące skrypty:
	\begin{itemize}
		\item \textbf{PowerUp}, odpowiadający za wywołanie efektu wzmacniającego gracza, oraz ciągły obrót obiektu wzmocnienia. Jest to skrypt abstrakcyjny, co oznacza, że nie jest przypisany bezpośrednio do obiektu, a~stanowi bazę dla skryptów, które mogą rozszerzać jego zachowanie. W~tym przypadku rozszerzeniem jest funkcja, która odpowiada za nałożenie efektu wzmacniającego na gracza.
		\item \textbf{HealthPowerUp}, będący rozszerzeniem skryptu PowerUp. W~ramach wzmocnienia skrypt przywracał pewną ilość punktów życia określoną przez parametr.
		\item \textbf{WeaponPowerUp}, będący rozszerzeniem skryptu PowerUp. Wzmocnienie w~tym przypadku polegało na zmianie broni gracza na tę, która była przypisana do wzmocnienia w~formie parametru.
	\end{itemize}
\end{enumerate}

Poza wyżej wymienionymi elementami, które stanowią część gry widoczną dla gracza, stworzone zostały elementy będące częścią menu głównego, a~także obiekty zarządzające nieposiadające reprezentacji graficznej. Do każdego z~nich został przypisany skrypt, który odpowiadał za kontrolowanie innych elementów rozgrywki:
\begin{itemize}
	\item \textbf{MainMenu}, zawierający funkcje, które uruchamiały oraz zamykały grę. W~ramach funkcji inicjującej rozgrywkę skrypt uruchamiał animacje wyświetlające ekran powitalny, a~następnie rozpoczynający faktyczną rozgrywkę.
	\item \textbf{PowerUpGenerator}, odpowiadający za generowanie obiektów wzmocnień w~trakcie gry. Kontrolował on tworzenie wybranego wzmocnienia w~losowo wybranej pozycji w~określonej odległości od gracza. Ilość wzmocnień znajdujących się  w~trakcie gry jest ograniczona, aby użytkownik odczuł, że są to elementy wyjątkowe. Wartość ta, wraz z~częstotliwością generowania wzmocnień i~odległością od gracza, w~jakiej obiekty mają być generowane, sterowane są przez parametry skryptu. 
	\item \textbf{EnemySpawner}, wykorzystywany do zarządzania logiką odpowiadającą za generowanie przeciwników w~świecie gry. Skrypt ten posiadając określoną w~parametrze listę szablonów przeciwników, którzy mają być generowani, co pewien czas tworzy każdego z~przeciwników w~formie fali. Każdy z~nich pojawia się w~losowo dobranych miejscach. Częstotliwość fal i~odległość, w~jakiej przeciwnicy są generowani od gracza, określane są poprzez parametry skryptu.
	\item \textbf{GameManager}, zarządzający zatrzymywaniem rozgrywki, oraz sterowaniem elementami po zakończeniu gry. Skrypt ten kontrolował flagi blokujące wszystkie inne obiekty w~przypadku zakończenia gry. Odpowiadał on także za wywołanie animacji wyświetlanych po śmierci gracza, zmianę sceny w~przypadku wyjścia z~gry, czy jej ponowne uruchomienie w~przypadku chęci ponownego rozpoczęcia rozgrywki.
	\item \textbf{Progress}, będący miejscem sterującym postępami gracza. Przy jego pomocy gromadzone są punkty zdobyte w~trakcie rozgrywki. Po zdobyciu punktów skrypt sprawdza, czy przekroczony został wynik wymagany do ukończenia poziomu. Jeżeli tak to usuwa wszystkie obiekty przeciwników i~pociski ze sceny, a~następnie w~zależności od tego, czy dany poziom był ostatni, uruchamia funkcje odpowiadające za zakończenie gry, lub przejście do kolejnego poziomu. W~przypadku końca rozgrywki, skrypt uruchamia animację wyświetlającą gratulacje dla gracza, a~następnie oznacza rozgrywkę jako zakończoną przy pomocy flagi ze skryptu GameManager. W~przypadku przejścia na kolejny poziom aplikowana jest nagroda w~postaci zwiększonych punktów życia, a~następnie ładowany jest kolejny poziom. Jednocześnie, niezależnie od tego, czy gracz ukończył poziom, aktualizowane są elementy interfejsu wyświetlającego ilość punktów gracz oraz sprawdzany jest warunek wymagany do uruchomienia trybu trudnego gry. Jeżeli tak, to lista generowanych przeciwników zostaje zmieniona na trudniejszą wersję, a~częstotliwość fal zostaje podwojona. W~ramach parametrów skryptu należy wyróżnić warunki uruchomienia trybu trudnego i~czas jego trwania, a~także listę poziomów w~grze. Ten ostatni parametr stanowi tak naprawdę główny rdzeń rozgrywki, ponieważ zawiera w~sobie szablon każdego z~poziomów, na który składają się: listy przeciwników, którzy mają być generowani, zarówno w~wersji klasycznej, jak i~trudnej, częstotliwość fal wrogów, wynik wymagany do ukończenia poziomu, liczba punktów życia dodana graczowi po jego ukończeniu, a~także flaga oznaczająca czy dany poziom jest ostatnim.
\end{itemize}

Wszystkie powyższe elementy stanowiły bazę dla podstawowej wersji gry. Parametry każdego z~obiektów zostały dobrane tak, aby gracz odczuwał postęp, który ma doprowadzić go ostatecznie do końca gry. Struktura projektu została zachowana w~formie dwóch scen, jednej odpowiedzialnej za menu gry, druga będąca sceną, w~której odbywała się faktyczna rozgrywka. Tak jak to zaznaczono podczas opisywania skryptów, całość gry rozgrywa się w~jednej scenie. Wynika to przede wszystkim z~powtarzalności poziomów, które różnią się wyłącznie parametrami. 

Ostatnim etapem tworzenia podstawowej wersji gry było dostosowanie sterowania do wykorzystywanego kontrolera Dualshock 4. Ponieważ Unity dla każdej z~gier może mieć zdefiniowaną listę nazw odpowiadającym danym przyciskom lub elementom, które mają pewien zakres działania, poza przystosowaniem standardowych nazw do odpowiednich przycisków na kontrolerze, dodane zostały osie, które zawierały w~sobie odczyty z~prawego analoga kontrolera. Pozwoliło to na wykorzystanie go do kontrolowania kierunku, w~który chciał spojrzeć gracz.

\section{Odczyt danych fizjologicznych i~zmian emocji}
%Opis elementów do odczytu emocji i~EMG, odczyty z~cheststrapa, komunikacja z~serwerem
Równolegle w~trakcie tworzenia implementacji podstawowej gry stworzony został interfejs umożliwiający pobieranie danych fizjologicznych i~odczytów akcelerometru z~urządzeń opisanych w~rozdziale~\ref{cha:architektura}. Pobrane informacje wykorzystano do przygotowania prostego interfejsu umożliwiającego implementację mechanizmów oddziaływania na strukturę gry w~zależności od otrzymanych danych i~tym samym domknięcie pętli afektywnej.

Pierwszym krokiem było przygotowanie skryptów umożliwiających odczyt danych bezpośrednio z~urządzeń. W~przypadku BITalino (r)evolution kit skorzystano z~rozwiązania dostępnego na stronie producenta~\cite{bitalino_apis}. Aby uniknąć ewentualnych problemów z~kompatybilnością, spośród dostępnych interfejsów programistycznych na platformę Unity, wybrano ten dostosowany do wyższych wersji oprogramowania. Bazując na przykładach oferowanych w~ramach interfejsu, stworzony został obiekt BITalino, który w~pełni będzie odpowiadał za integrację z~urządzeniem. Przypisano do niego następujące skrypty:
\begin{itemize}
	\item \textbf{BitalinoSerialPort}, udostępniony jako część wykorzystanego interfejsu. Skrypt umożliwiał konfigurację parametrów związanych z~nawiązaniem połączenia z~urządzeniem poprzez transmisję szeregową, zarówno przez Bluetooth, jak i~kabel USB. W~ramach parametrów możliwe było ustawienie między innymi limitów czasu oczekiwania na odczyt i~zapis danych, jednak najistotniejsza była możliwość wprowadzenia nazwy kanału, przy pomocy którego możliwa była komunikacja z~urządzeniem. 
	\item \textbf{BitalinoManager}, udostępniony jako część wykorzystanego interfejsu. Skrypt ten umożliwia przede wszystkim konfigurację listy wykorzystywanych kanałów i~określenia, jakiego rodzaju dane są przypisane do każdego z~nich. W~przypadku przygotowywanego projektu ustalony został wyłącznie jeden kanał przyjmujący odczyty z~elektromiogramu. Skrypt umożliwia także ustalenie częstotliwości wysyłania danych. Ze względu na chęć uzyskania jak najdokładniejszych odczytów, zdecydowano się na ustawienie najwyższej możliwej wartości, czyli tysiąca próbek na sekundę.
	\item \textbf{BitalinoReader}, udostępniony jako część wykorzystanego interfejsu. Skrypt służy do zarządzania przetwarzaniem danych z~płytki, tego, w~jakiej postaci są zwracane, oraz jak wielki jest bufor, w~którym są one przechowywane. Jego rozmiar ustawiono na sto ostatnich elementów. Wybór takiej wartości wynika przede wszystkim ze względu na chęć uzyskania jak najmniejszego opóźnienia od momentu odczytu danych bezpośrednio z~urządzenia do momentu wykorzystania ich przetworzonej wersji. Ponieważ sygnał z~elektromiografu ma służyć wykryciu zmian w~napięciu mięśni, nie była tutaj wymagana wysoka ilość próbek.
	\item \textbf{SensorController}, przygotowany w~ramach niniejszej pracy magisterskiej. Głównym zadaniem tego skryptu był odczyt w~czasie rzeczywistym bufora danych, wyznaczanie średniej z~wartości bezwzględnych odczytów elektromiografu, a~następnie sprawdzenie, czy przez określony czas miało miejsce napięcie mięśni przedramienia. Użycie wartości bezwzględnej wynika z~oscylacji występujących w~sygnale pobranym z~elektromiografu. Wykrycie napięcia mięśni oparte zostało na warunku:
	$$
	|EMG|_{avg} \geq mul \cdot |EMG|_{base}
	$$
	gdzie $|EMG|_{avg}$ jest aktualnie odczytaną średnią wartością, $mul$ mnożnikiem ustawianym jako parametr umożliwiający regulację wykrycia napięcia mięśni, a~$|EMG|_{base}$ średnim pomiarem bazowym. Ostatnia z~wartości jest wyznaczana podczas fazy kalibracji odbywającej się po rozpoczęciu pomiarów. Przez ustaloną parametrem ilość sekund, w~których trakcie użytkownik nie powinien napinać mięśni przedramienia, zbierane są odczyty z~elektromiografu, a~następnie na ich podstawie obliczana jest wartość służąca jako pomiar referencyjny, z~którym porównywane są odczyty w~trakcie rozgrywki.
\end{itemize}
Dodanie czasu, przez jaki miał być napięty mięsień oraz mnożnika w~warunku miało na celu odrzucenie krótkich, losowych ruchów ręką, jakie mogły wystąpić w~trakcie korzystania z~kontrolera. Pozwoliło to także dać użytkownikowi świadomość kontroli nad napięciem mięśni, ponieważ musiał wykonać tę czynność przez określony czas.

Aby obiekty, które mają reagować na napięcie mięśni, mogły w~prosty sposób być o~tym informowane, został wykorzystany mechanizm zdarzeń z~języka C\#. W~ramach skryptu SensorController przygotowany został delegat, będący typem przechowującym referencję do metody i~określającym jakie parametry i~typ zwrotny powinna zawierać metoda, której sygnaturę określa delegat. Następnie dodane zostało zdarzenie o~typie przygotowanego delegata, które służy jako miejsce rejestracji i~wywołania metod, które mają obsłużyć dane zdarzenie. W~przypadku skryptu SensorController jest ono wywoływane w~momencie wykrycia napięcia mięśni przez określony czas. Tak przygotowany mechanizm pozwala na prawie całkowite uniezależnienie elementów związanych z~pomiarami fizjologicznymi od skryptów będących częścią implementacji gry.

Kolejnym krokiem było przygotowanie skryptów do odczytu sygnałów z~opaski Garmin HRM-Run i~akcelerometru wbudowanego w~kontroler Dualshock. Zostaną one następnie wykorzystane w~skryptach komunikujących się z~modelem opisanym rozdziale~\ref{cha:predykcja} i~zwracających odczyty emocji użytkownika w~trakcie rozgrywki.

Podobnie jak w~przypadku odczytów z~płytki BITalino (r)evolution kit, do pomiaru tętna wykorzystana została biblioteka do obsługi protokołu ANT+ oraz przykład znajdujące się na stronie producenta~\cite{ant_sdk}. Przy ich pomocy przygotowano następujące skrypty umożliwiające odczyt tętna z~opaski:
\begin{itemize}
	\item \textbf{AntReader}, przygotowany na podstawie przykładu udostępnionego przez twórców biblioteki. Kod został dostosowany w~taki sposób, aby można było uruchomić odczyt przy pomocy funkcji. Do najważniejszych parametrów skryptu należy przede wszystkim numer i~typ urządzenia, z~jakiego mają być odczytywane dane. Ponieważ odczyty z~urządzenia przychodzą w~formie ramki z~danymi, do skryptu dodany został parser, który przygotowuje obiekt zawierający informację na temat wartości tętna, ilości uderzeń od rozpoczęcia odczytów, czas ostatniego odczytu, oraz wartość interwału pomiędzy ostatnimi dwoma uderzeniami w~milisekundach. Tak przygotowany obiekt jest następnie wysyłany jako parametr zdarzenia, które także zostało dodane jako modyfikacja przykładu. Takie podejście wynika przede wszystkim z~protokołu, który bazuje na przesyłaniu zdarzeń w~momencie wystąpienia jakiejś akcji.
	\item \textbf{HeartRateManager}, zarządzający danymi przesyłanymi przez skrypt AntReader. Jego głównym zadaniem jest przechowywanie obiektów z~informacją na temat pracy serca w~buforze, którego rozmiar jest zadany przez parametr. Skrypt ten umożliwia także wyizolowanie z~bufora wartości tętna i~interwałów pomiędzy uderzeniami w~formie tablic.
\end{itemize}

W przypadku odczytów akcelerometru z~kontrolera Dualshock 4~producent udostępnia oprogramowanie wbudowane w~silnik Unity, jednak jest ono dostępne wyłącznie dla osób projektujących gry na konsolę PlayStation 4. W~związku z~tym wykorzystany został odpłatny dodatek Rewired, udostępniający obsługę wielu kontrolerów do gier, nie tylko na poziomie obsługi przycisków, ale również wbudowanych funkcjonalności takich jak kontrola wibracji, oświetlenia, czy odczytów ze wbudowanych w~kontroler sensorów, takich jak akcelerometr czy żyroskop. Do odczytów z~kontrolera i~ich interpretacji przygotowane zostały następujące skrypty:
\begin{itemize}
	\item \textbf{AccelerationReader}, odpowiadający za odczyt i~wstępną filtrację danych z~akcelerometru. Częstotliwość odczytu jest ustalana za pomocą parametru skryptu, a~każdy odczyt jest filtrowany przy pomocy filtru Kalmana, aby pozbyć się ewentualnych szumów.
	\item \textbf{AccelerationHandler}, odpowiadający za przechowywanie i~analizę pomiarów zebranych przy pomocy skryptu AccelerationReader. Dane przechowywane są w~dwóch listach: jednej przeznaczonej do fazy kalibracji oraz drugiej będącej buforem odczytów z~określonej parametrem ilości czasu. Do określenia aktywności użytkownika wykorzystano zryw, czyli zmiana wartości przyspieszenia w~czasie. W~trakcie fazy kalibracji po zebraniu danych z~akcelerometru do przygotowanej listy obliczana była średnia wartość zrywu, która posłuży jako pomiar referencyjny. W~ramach przygotowanej funkcji skrypt umożliwia pobranie aktualnej aktywności użytkownika w~postaci jednego z~trzech stanów: bardzo spokojny, spokojny i~podekscytowany. Funkcja oblicza wartość zrywu z~aktualnie pobranych pomiarów, a~następnie określa czy użytkownik jest podekscytowany na podstawie warunku:
	$$
	jerk_{avg} \geq mul \cdot jerk_{base}
	$$
	gdzie $jerk_{avg}$ jest aktualnie odczytaną wartością zrywu, $mul$ mnożnikiem ustawianym jako parametr umożliwiający regulację poziomu granicznego dla ekscytacji, a~$jerk_{base}$ jest pomiarem zrywu uzyskanym w~trakcie kalibracji. Następnie, jeśli stan nie został określony jako podekscytowany, sprawdzana jest ostatnio odczytana wartość. Jeżeli gracz był spokojny, a~ostatni pomiar odbył się w~określonym czasie, to skrypt uznawał użytkownika za bardzo spokojnego. W~przeciwnym wypadku zwracany był stan spokojny.
\end{itemize}

Tak przygotowane skrypty do odczytu i~wstępnej analizy danych z~opaski do pomiaru tętna i~akcelerometru zostały następnie wykorzystane do ustalenia stanu emocjonalnego użytkownika. Umieszczono je w~obiekcie EmotionManager, który skupia wszystkie skrypty odpowiedzialne za określenie stanu emocjonalnego użytkownika. Aby powiązać odczytane dane z~modelem uczenia maszynowego oraz ustalić emocje odczuwane przez gracza, do obiektu EmotionManager dodane zostały następujące skrypty:
\begin{itemize}
	\item \textbf{ClassifierApiManager}, odpowiadający za komunikację z~serwerem zawierającym model rozpoznający emocje. Skrypt wykorzystując dane na temat tętna i~interwałów pomiędzy kolejnymi uderzeniami, które znajdują się w~skrypcie HeartRateManager, wykonuje zapytania do serwera i~zapisuje zwracana klasę emocji oraz parametry, dla których dana emocja została zwrócona. Skrypt zawiera także flagę informującą, czy od momentu ostatniego odczytu emocji przez inne skrypty była ona aktualizowana.
	\item \textbf{EmotionManager}, zarządzający pozostałymi skryptami do odczytywania emocji i~będący punktem wyjściowym dla przekazywania stanu emocjonalnego gracza do innych obiektów. Głównym zadaniem skryptu jest uruchomienie pobierania danych z~opaski i~akcelerometru, a~następnie określenie emocji użytkownika na podstawie klasy zwróconej przez model rozpoznający emocję oraz stanu pobudzenia zwracanego przez skrypt AccelerationHandler. W~momencie pobierania emocji wywoływane jest zapytanie do serwera przy pomocy skryptu ClassifierApiManager o~stan emocjonalny użytkownika na podstawie danych z~opaski. Zwrócona klasa emocji jest konwertowana do obiektu zawierającego poziomy wartości \textit{valence} i~\textit{arousal}, a~następnie przy pomocy odczytanego z~akcelerometru stanu pobudzenia, są one weryfikowane. Ponieważ pomiar \textit{arousal} jest związany bezpośrednio z~pobudzeniem gracza, to właśnie ta wartość była modyfikowana. Jeżeli stan zwracany przez odczyty z~akcelerometru wskazywał na pobudzenie użytkownika, poziom \textit{arousal} był zwiększany, natomiast w~przypadku bardzo spokojnej gry, był on zmniejszany. Dzięki takiemu podejściu można było łatwo weryfikować klasę zwracaną przez model, która nie zawsze mogła dokładnie odzwierciedlać stan emocjonalny gracza w~danym momencie rozgrywki. Po odczytaniu emocji następowało wywołanie zdarzenia o~nowej emocji, które jako parametr przyjmowało emocję odczytaną w~danym momencie oraz stan poprzedni. Wykorzystanie poprzedniej emocji miało na celu rozszerzenie kontekstu zmian emocji użytkownika i~ich interpretację przez konkretne elementy gry. Do najważniejszych parametrów skryptu EmotionManager należą przede wszystkim czas poświęcony na kalibrację oraz parametr określający co ile ma zostać wykonane zapytanie o~stan emocjonalny użytkownika. 
\end{itemize}

Obiekty BITalino i~EmotionManager zostaly następnie połączone w~hierarchii pod obiektem AffectiveManager. Obiekt ten miał służyć jako rdzeń przygotowywanego w~ramach pracy magisterskiej interfejsu. Tak przygotowana hierarchia umożliwiała łatwe jego wprowadzenie do istniejącego już kodu gry. Do obiektu AffectiveManager został przypisany także skrypt o~tej samej nazwie, którego głównymi zadaniami było uruchamianie oraz wyłączanie mechanizmów opisanych powyżej, a~także rozpoczynanie fazy kalibracji dla mechanizmu do odczytywania emocji oraz odczytów z~elektromiografu. Dodany został także obiekt Logger, którego skrypt odpowiadał za zapisywanie informacji o~odczytanych stanach emocjonalnych oraz momentach wykrycia napięcia mięśni. W~przypadku odczytywania emocji zapisywane są poziomy \textit{valence} i~\textit{arousal} po weryfikacji odczytami z~akcelerometru oraz wartości cech modelu, dla których zostały one wyliczone. Pomiary te mogą posłużyć jako dodatkowe dane uczące, które mogą poprawić skuteczność modelu opisanego w~rozdziale~\ref{cha:predykcja}. W~przypadku odczytów z~elektromiografu zapisywane były momenty napięcia mięśni przedramienia wraz ze średnią wartością z~elektromiografu. Każde zdarzenie było zapisywane w~pamięci wraz z~czasem jego wystąpienia, a~w momencie zakończenia rozgrywki były one zapisywane w~pliku CSV.

\section{Domknięcie pętli afektywnej}
Po stworzeniu opisanego w~poprzedniej sekcji interfejsu kolejnym krokiem było domknięcie pętli afektywnej. Oznaczało to uzależnienie pewnych elementów gry od stanu emocjonalnego i~reakcji użytkownika. Aby to osiągnąć, wymagana była modyfikacja podstawowej wersji gry i~zmiana działania jej mechanik w~zależności od wartości zwracanych przez skrypty EmotionManager i~SensorController.

Aby umożliwić integrację gry z~interfejsem, w~głównym menu gry przygotowana została opcja, która decyduje o~tym, czy mechaniki afektywne mają zostać uruchomione po rozpoczęciu gry. Następnie, w~ramach skryptu MainMenu, zmodyfikowany został proces wyświetlania wprowadzenia. W~przypadku wersji afektywnej wyświetlony zostaje tekst informujący użytkownika o~przeprowadzanej na początku kalibracji interfejsu oraz zasadach, których powinien przestrzegać w~trakcie jej trwania (rys.~\ref{fig:introductions}). Użytkownik proszony jest o~uspokojenie się, wzięcie kilku głębokich oddechów oraz nieporuszanie kontrolerem w~trakcie przeprowadzania kalibracji. W~tym samym momencie uruchamiany zostaje odczyt danych z~urządzeń pomiarowych, a~po kilku sekundach rozpoczynana jest kalibracja trwająca przez określony w~parametrach interfejsu czas. Wcześniejsze uruchomienie odczytu pozwoliło na odrzucenie pierwszych pomiarów z~urządzeń, które mogły charakteryzować się dużym błędem ze względu na start urządzeń.
\begin{figure}
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{images/nonaffectiveintroduction.png}
		\caption{Wprowadzenie w~wersji podstawowej}
		\label{fig:nonaffectiveintroduction}
	\end{subfigure}%
	\begin{subfigure}{0.5\textwidth}
		\centering
		\includegraphics[width=0.9\linewidth]{images/affectiveintroduction.png}
		\caption{Wprowadzenie w~wersji afektywnej}
		\label{fig:affectiveintroduction}
	\end{subfigure}
	\caption{Ekran wprowadzenia dla obu wersji gier}
	\label{fig:introductions}
\end{figure}

Kolejnym krokiem w~integracji interfejsu było przygotowanie mechanik afektywnych, które wpływają na poszczególne elementy rozgrywki w~zależności od odczuwanych przez użytkownika emocji lub napięcia mięśni przedramienia. W~ramach skryptów odpowiadających za konkretne elementy rozgrywki przygotowane zostały funkcje, które następnie zarejestrowano jako obserwatorzy wystąpienia nowej emocji lub napięcia mięśni. Aby ułatwić interpretację poziomów \textit{valence} i~\textit{arousal} zwracanych w~ramach obiektu reprezentującego odczuwaną emocję, stworzone zostały stałe, które przypisują każdą z~par obu wartości do konkretnej emocji. Interpretacja każdej z~kombinacji została przedstawiona w~tabeli~\ref{tab:emotions}. W~ramach zaimplementowanych mechanik afektywnych można wyróżnić:
\begin{enumerate}
	\item \textbf{Aktywacja mocy specjalnej po wykryciu napięcia mięśni przedramienia}. Mechanika ta stanowi alternatywę dla uruchomienia mocy specjalnej przy pomocy przycisku na kontrolerze. Uruchomienie jej bez wyłączania akcji z~podstawowej wersji gry pozwala użytkownikowi wybrać sposób aktywacji, który jest dla niego wygodniejszy.
	\item \textbf{Aktywacja mocy specjalnej w~momencie, gdy gracz przez dłuższy czas odczuwa złość}. W~odróżnieniu od poprzedniego punktu, w~tym przypadku moc specjalna aktywowana jest niezależnie od jej dostępności w~momencie, gdy poprzednia i~aktualnie odczytana emocja to złość. 
	\item \textbf{Zmiana ilości punktów życia gracza na podstawie odczuwanych emocji}. Można wyróżnić tutaj następujące możliwości:
	\begin{itemize}
		\item Odebranie graczowi 40\% punktów życia w~przypadku odczuwania przez dłuższy czas emocji neutralnej, zmęczenia lub zrelaksowania. Taka reakcja miała na celu pobudzenie gracza do skupienia się na rozgrywce ze względu na nagłą trudną sytuację.
		\item Odebranie graczowi 20\% punktów życia w~momencie odczuwania przez dłuższy czas szczęścia lub ekscytacji. Emocje te zostały wydzielone do lżejszej wersji negatywnego efektu, aby uniknąć nadmiernego zdenerwowania gracza, ale jednocześnie wzbudzić w~nim potrzebę skupienia się na grze.
		\item Przywrócenie 10\% punktów życia w~momencie odczuwania smutku lub strachu. Efekt ten miał posłużyć jako pomoc dla gracza i~wywołanie przez to u niego pozytywnych emocji.
	\end{itemize}
	\item \textbf{Aktywacja dodatkowych fal przeciwników w~przypadku odczuwania przez gracza emocji neutralnej, zrelaksowania, zmęczenia lub szczęścia}. W~przypadku trzech pierwszych emocji mechanika ta miała na celu postawienie graczowi wyzwania. Uruchomienie jej w~momencie odczuwania szczęścia przez gracza miało na celu wywołanie u niego emocji przeciwstawnych takich jak strach czy złość.
	\item \textbf{Aktywacja i~dezaktywacja trybu trudnego gry w~zależności od odczuwanej emocji}. Mechanika ta zastępowała jej podstawową wersję opartą na częstotliwości zdobywania punktów. W~przypadku odczuwania przez gracza złości lub strachu była ona dezaktywowana, natomiast aktywacja następowała w~momencie odczuwania przez gracza emocji neutralnej, zrelaksowania lub zmęczenia.
\end{enumerate}

\begin{table}
	\centering
	\caption{Interpretacja kombinacji poziomów \textit{valence} i~\textit{arousal} jako emocje.}
	\label{tab:emotions}
	\begin{tabular}{|l|l|l|l|}
		\hline
		\diagbox[width=8em]{\textbf{Valence}}{\textbf{Arousal}}      & LOW    & MEDIUM           & HIGH          \\ \hline
		LOW    & Smutek & Złość        & Strach \\ \hline
		MEDIUM & Zmęczenie  & Emocja neutralna & Zaskoczenie     \\ \hline
		HIGH   & Zrelaksowanie & Szczęście      & Ekscytacja    \\ \hline
	\end{tabular}
\end{table}

Implementacja interfejsu do rozpoznawania emocji i~zachowań gracza umożliwiła stworzenie gry zawierającej pętlę afektywną. Aby zrealizować w~pełni założenia programowania afektywnego, każda z~mechanik zmieniała rozgrywkę w~taki sposób, aby wzbudzić w~użytkowniku inny rodzaj emocji od aktualnie odczuwanych. Przygotowany interfejs umożliwił łatwą implementację każdej z~nich bez konieczności modyfikacji oryginalnego kodu gry dzięki rejestracji funkcji uruchamianych w~momencie odczytania emocji.
